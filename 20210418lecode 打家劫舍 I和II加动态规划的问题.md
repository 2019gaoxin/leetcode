```
1、永远不放弃，永远不找借口
2、永远找方法！
3、永远不要情绪化！
4、永远要积极向上，百折不挠！
5、永不说人负面！
6、一切都是我自己的问题，人不行干啥都不行，人行干啥都行！

```

### 每一分利润都是玩命干出来的



# 错误答案：虽然有很多错误，但都是为了进步

### 万法唯心现，你的态度必须良好

# 我始终相信把事情做到极致是有力量的

# 打家劫舍一（动态规划问题入门）

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额

来源：力扣（LeetCode）输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。



# 动态规划

### 动态规划四个解题步骤

####1.定义子问题

​	原问题：从全部房间里可以偷到的最大金额。

​	子问题：从k个房间里可以偷到的最大金额。

​	子问题f(k)要由f(k-1)得出，f(k-1)要由f(k-2)得出。

####2.写出子问题的递推关系

​	设一共有n个房子，每个房子的金额m0,m1,m2....m(n-1),

​	子问题：前k个房子m0,m1,m2...m(k-1)

​	那么问题来了这k个房子怎么偷？

​	我们现在逆向思考，毕竟这是动态规划的问题？那就去考虑最后一间房子偷还是不偷。

​	方案一：最后一间不偷，那么k-1间房子怎么偷就变成了一个子问题

​	方案二：最后一间偷   那么前k-2间房子就变成了一个新的子问题，

f(k) = max{f(k-1),m(k-1)+f(k-2)}

​	边界条件： 0个房子 f(0) = 0;1个房子f(1) = m0;	

####3.确定DP数组的计算顺序

99%的情况 使用自底向上的方法，使用dp数组的循环方法。

f(k) = 偷k间房子的最大金额

f(k)  对用的房子 0到k-1个房子；  放在

dp(k)的数组空间中

f(k) 的解决是依靠f(k-1) 和 f(k-2)，dp[k] 依赖 dp[k-1]和dp[k-2]



####4.空间优化（可以进行或不进行）



PS：DP数组也叫"子问题数组"，DP数组中每一个元素都对应一个子元素

```java
public int rob(int[] nums) {
    if (nums.length == 0) {
        return 0;
    }
    // 子问题：
    // f(k) = 偷 [0..k) 房间中的最大金额

    // f(0) = 0
    // f(1) = nums[0]
    // f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }

    int N = nums.length;
    
    //为什么是N+1 因为0间房子的情况也加进去了
    int[] dp = new int[N+1];//新建一个dp数组，这个数组是储存解决方法的
    
    dp[0] = 0;//当没有房子的时候，可以取得的钱的数量为0
    
    dp[1] = nums[0];//当只有一个房子的时候，可以取到的金额为这一个房子的数量
    
    for (int k = 2; k <= N; k++) {	//实现一个循环，一层一层叠加，
        
        dp[k] = Math.max(dp[k-1], nums[k-1] + dp[k-2]);//一步一步的选择
        
    }
    return dp[N];   //返回最后的解决方案；
}

//	作者：nettee
//	来源：力扣（LeetCode）

```

#打家劫舍二

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 

示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：

输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。

来源：力扣（LeetCode）

###

就是偶次项相加，奇次项相加



[1,3,1,3,100]     102 103 这样奇偶就不可以

# 所以我们选择动态规划的问题



### 这里提到了一种做题思路，动态规划问题dp

dp把大问题拆分成小问题，然后可以递推的分析

### 1.定义子问题

这个第二题是环形的

因此我们需要考虑要不要选择第一个和最后一个房屋

​	原问题：从 n所房屋中可以获得的最大的金额

​	子问题：从k所房屋里可以获得的最大金额

​	f(k),要从f(k-1)和f(k-2)中获得所以还是循环求解

现在考虑边界问题    

f(0) =0;

f(1) = m1;

这个是一个环  也就是第一个选了最后一个就不可以选了



现在我要求子问题f(k)    k间房子的最大金额

最后一间偷还是不偷

比如这是前k间房子		| 0  | 1  |  2   |  3   |  4    |  5    |......| k-2| k- 1|

假如 第 k 间被偷了 那么子问题就是 前(k -2)间偷不偷 

假如第k间不偷，那么就是子问题 前（k-1）间偷还是不偷；

前k间房子	m0,.....，mk-1;

​	f(k) = max{    f(k-1)     ,      f(k-2)+m(k-1)   };

​	f(0) = 0;

​	f(1) = m0;

```java
int len = nums.length;
int[] dp = new int[len +1]；
dp[0] = 0;
dp[1] =nums[0];
dp[2] = Math.max{dp[0],dp[1]};
//当房屋大于两间的时候就要考虑首位相连的问题；
dp[3] = Math.max{}
```



那我们就 |0| 1| 2 | 3 | 4|。。。|k-1|

假设有k间房子 k>3;这时需要考虑首尾相连	首位相连无非就是选第一个还是选最后一个



那到现在子问题考虑全了吗？

​    房子从0开始 /。。。。/k-2/k-1/0/1/2/。。。。/

第一个为0

最后一个为k-1 

1. 选第一个

   则不选最后一个，那么数组的下标就是从 0开始到 N-2结束

   比如第二个为99999，k-2=99999，这样就可以，那也无所谓了

2. 不选第一个

   那么就可以选最后一个，数组的下标就是[ 1,N-1]

```java
class Solution {
    public int rob(int[] nums) {
       int[] dp = new int[nums.length + 1];
       if(nums.length==1){
           return nums[0];
       }
       if(nums.length==0){
           return 0;
       }
       dp[0] = 0;
       dp[1] = nums[0];
       int[] nums1 = new int[nums.length-1];
       int[] nums2 = new int[nums.length-1];
       for(int i =0,j=1;i < nums.length-1;i++,j++){
           nums1[i] = nums[j]; 
       }
       for(int i=0;i < nums.length-1;i++){
           nums2[i] = nums[i];
       }
       int first = Norob(nums1);
       int second = Norob(nums2);
       return Math.max(first,second);

    }
    public int Norob(int[] nums){

        int[] dp = new int[nums.length + 1];
        dp[0] = 0;
        dp[1] =nums[0];
        
        for(int k=2;k<=nums.length;k++){
            dp[k]=Math.max(dp[k-1],dp[k-2]+nums[k-1]);
        }
        return dp[nums.length];

    }

    
}
```

### 不努力就会进入消化道，奋斗！













